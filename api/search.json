[{"id":"9262da4920e12b0b152137c2b65fc583","title":"next获取数据","content":"fetchnext为fetch做了功能上的扩展，\n\n允许设置缓冲\n\njavascriptfetch(&#39;https://...&#39;, &#123; next: &#123; revalidate: 3600 &#125; &#125;)\n像react query一样tag：\n\njavascriptfetch(&#39;https://...&#39;, &#123; next: &#123; tags: [&#39;collection&#39;] &#125; &#125;) //标界tag\n\n revalidateTag(&#39;collection&#39;) //使数据失效","slug":"next获取数据","date":"2023-11-28T02:25:52.000Z","categories_index":"","tags_index":"","author_index":"CeazzZY"},{"id":"82795e5babeacda4e2079c9fa98d4fbf","title":"next路由和路由跳转","content":"Routenext 的路由与 react 不同，不需要自己写路由表，在 next 中之需要你在 app&#x2F;pages（next14 中推荐 app）文件夹下写对应的文件夹或文件就能自动生成路由。不同名称的文件在路由中也有对应的功能。 components 之类的文件夹也能加到 app 文件夹中，但只要没有 page.tsx 就不会作为路由。\n页面pagepage 作为路由展示的主体内容，每一个作为路由的文件夹都必须有这个文件。\nlayoutlayout 作为不同子路由共用的布局，eg：\njavascriptexport default function DashboardLayout(&#123;\n  children,\n&#125;: &#123;\n  children: React.ReactNode,\n&#125;) &#123;\n  return (\n    &lt;section&gt;\n      &lt;div&gt;&lt;/div&gt; //共用UI\n      &#123;children&#125; //page展示的地方\n    &lt;/section&gt;\n  );\n&#125;放在 app 根 layout 需要包含 html 和 body 标签，因为 Next.js 不会自动创建它们。并且只有根 layout 能包含 html 和 body 标签。\ntemplatetemplate 的功能和 layout 十分相似，都是为子路由提供共用的 UI，但 template 在切换子路由后会重新渲染，layout 并不会，所以当共用 UI 中有依赖 useEffect 或根据逻辑展示不同内容的话 template 比 layout 更合适。\njavascriptexport default function Template(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;\n  return &lt;div&gt;&#123;children&#125;&lt;/div&gt;;\n&#125;loading用于处理加载中的 UI。并且可以使组件以一部分一部分的方式传输，提高性能。eg:\njavascriptexport default function Loading() &#123;\n  return &lt;div&gt;...&lt;/div&gt;;\n&#125;使用eg：\njavascript&lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;&lt;/Suspense&gt;跳转next 中切换路由的方式和 react 很相似，大体分为 link 跳转，和函数式跳转。\n&lt;link&gt;与 react-route 大体相似，包含 href，replace，scroll，prefetch 这几个属性，eg：\njavascript&lt;Link\n  className=&#123;`link $&#123;pathname === &quot;/&quot; ? &quot;active&quot; : &quot;&quot;&#125;`&#125; //是否处于活动状态\n  href=&#123;&#123;\n    pathname: \"/about\",\n    query: &#123; name: \"test\" &#125;,\n  &#125;&#125;\n  replace=&#123;false&#125; //决定跳转方式\n  prefetch=&#123;false&#125; //决定是否预渲染\n  scroll=&#123;false&#125; //决定是否默认到顶部\n&gt;\n  About\n&lt;/Link&gt;useRouter()与 react-route 中 navigate 大体相似，eg：\njavascriptconst router = useRouter();\nconst navigate = () =&gt; router.push(&quot;/home?id=1&quot;, &#123; scroll: false &#125;);\nrouter.replace();\nrouter.refresh();\nrouter.forward();\nrouter.back();Metadata为了更好的 SEO，可以通过 Metadata 来修改 title 内容，eg：\njavascript//在page中\nimport &#123; Metadata &#125; from &quot;next&quot;;\n\nexport const metadata: Metadata = &#123;\n  title: &quot;about&quot;,\n&#125;;路由组以(filename)创造的文件夹不会影响路由的 URL，但可以多个路由放到一个文件夹中，使路由结构更清晰。在路由组文件夹下还可以有 layout 文件来展示一个组中的共用 UI，如果是在 app 下的根 layout,可以删除 app 中的 layout，然后在每个路由组内添加一个 layout 文件，每个 layout 文件都有 html 和 body 标签。\n动态路由当你不确定 URL 时可以通过[filename]或[[filename]]的格式来创建文件夹。eg: blog&#x2F;[id] -&gt; blog&#x2F;1 -&gt; {id:1}[[filename]]可以匹配到 &#x2F;blog 但[filename]不行。在子组件中通过 props 的接收 params。eg:\njavascriptexport default function Page(&#123; params &#125;: &#123; params: &#123; slug: string &#125; &#125;) &#123;\n  return &lt;h1&gt;My Page&lt;/h1&gt;;\n&#125;[…folderName]可以接收后面的所有参数。eg：blog&#x2F;[…slug] -&gt; blog&#x2F;1&#x2F;a -&gt; {slug:[1,”a”]}\n","slug":"next路由和路由跳转","date":"2023-11-28T02:15:29.000Z","categories_index":"","tags_index":"","author_index":"CeazzZY"},{"id":"95e1d6877ea327ec4515e34d7f460889","title":"zustand","content":"为什么要使用 zustand\n写法比较简便，你甚至不需要根组件外面包裹一层东西，足够轻量（核心代码只有 1kb）。\n写法大部分（小部分写法我感觉也很逆天）比较符合我的审美（仅仅是我的审美），不需要结合上下文，纯 hook 式调用。\n写法更接近于 redux，虽然我很讨厌 redux 繁琐的写饭，但不不得不承认，今后进入公司一些老项目大概率会是用的 redux，熟悉类似 redux 写法的话，有利于上手。\n在新兴的状态管理库中，热度基本排在数一数二的位置，github 上目前已有 37k 的 star，谈热度并不是让大家去盲目的跟风，庞大的社区可以给为使用者提供解决问题的成熟方案，和各种各样的中间件来扩展功能。\n\n初始化一个简单 storejavascriptimport &#123; create &#125; from &quot;zustand&quot;;\n\ninterface IStu &#123;\n  number: number;\n  add: () =&gt; void;\n  sub: () =&gt; void;\n  remove: ()=&gt;void\n&#125;\n\nconst store = create&lt;IStu&gt;()((set, get) =&gt; &#123;\n  return &#123;\n    number: 0,\n    add: () =&gt; &#123;\n      set((state) =&gt; &#123;\n        return &#123;\n          number: ++state.number,\n        &#125;;\n      &#125;);\n    &#125;,\n    sub: () =&gt; &#123;\n      set((state) =&gt; (&#123; number: --state.number &#125;));\n    &#125;,\n    remove: () =&gt; set(&#123; number: 0 &#125;),\n    otherAdd: () =&gt; &#123;\n      set(&#123; number: ++get().number &#125;);\n    &#125;,\n  &#125;;\n&#125;);\n\nexport default useStudentsStore;\n几个要注意的点：\n\n使用 ts 的话一定，要写类型声明不然会报错。\n范式声明后面要加括号，至于为什么我没太看懂（大概是跟柯里化相关），有兴趣可以看下这篇文章。\n看清楚 create 里的结构:\n\njavascriptcreate(()=&gt;&#123; //create中传入的是一个函数，函数接收一系列方法，之后会提到\n  return&#123;  //函数返回的是一个对象，对象中包含储存的值和修改值的方法。\n    ...\n  &#125;\n&#125;)消费 storejavascriptconst number = useStudentsStore((state) =&gt; state.number);\nconst add = useStudentsStore((state) =&gt; state.add); //最基本的使用方式\n\nconst &#123; number, add, sub, remove &#125; = useStudentsStore(); //仅使用于需要全部全部状态和方法，可能会引起不必要的渲染如果需要使用多个状态或值的话声明会很麻烦，所以作者写了一个 util，我们使用时只需要复制粘贴这段代码即可,愿文章\njavascriptimport &#123; StoreApi, UseBoundStore &#125; from &#39;zustand&#39;\n\ntype WithSelectors&lt;S&gt; = S extends &#123; getState: () =&gt; infer T &#125;\n  ? S &amp; &#123; use: &#123; [K in keyof T]: () =&gt; T[K] &#125; &#125;\n  : never\n\nexport const createSelectors = &lt;S extends UseBoundStore&lt;StoreApi&lt;object&gt;&gt;&gt;(\n  _store: S,\n) =&gt; &#123;\n  const store = _store as WithSelectors&lt;typeof _store&gt;\n  store.use = &#123;&#125;\n  for (const k of Object.keys(store.getState())) &#123;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (store.use as any)[k] = () =&gt; store((s) =&gt; s[k as keyof typeof s])\n  &#125;\n\n  return store\n&#125;javascript//store中用createSelectors包住store\nconst useStudentsStore = createSelectors(store);\n\n//在组件中用use的方式引入\nconst add = useStudentsStore.use.add();\nconst sub = useStudentsStore.use.sub();\nconst remove = useStudentsStore.use.remove();其实就算使用 selectors 的方式引入还是会有点麻烦.\nuseshallowuseShallow 是 zustand 中内置的一个 hook，使用 useShallow 为我们消费 store 提供了另一种方法。\njavascriptconst &#123; add1 &#125; = useShallowStore(\n  useShallow((state) =&gt; (&#123;\n    add1: state.add1,\n  &#125;))\n);这种写法可以避免组件的无意义刷新，简化了消费 store 的代码\n中间件devtools因为 zustand 是 redux 系的状态管理库，所以 zustand 可以直接使用 redux 的调试工具\njavascriptconst store = create(\n  devtools(\n    ()=&gt;&#123;\n      ...\n    &#125;\n  )\n)\nimmerzustand 中的 set 是一个纯函数，所以 state 是 immutable，当我们需要修改乔迁套很深的对象时需要大量使用对象解构，这样的写法非常麻烦。我们可以使用中间件 immer 来简化写法。首先 immer 并没有内置在 zustand 中，需要手动下载\ntxtpnpm i immer使用方式：\njavascriptconst store = create(\n  immer((set) =&gt; (&#123;\n    number: &#123;\n      mathTeacher: &#123;\n        man: 0,\n        woman: 0,\n      &#125;,\n      EnglishTeacher: 0,\n    &#125;,\n    addMathManTeacher: () =&gt; &#123;\n      set((state) =&gt; &#123;\n        state.number.mathTeacher.man += 1; //我们可以直接修改对象的属性\n      &#125;);\n    &#125;,\n  &#125;))\n);persist这个中间件用于持久化仓库里的值，即使页面刷新也不会丢失，\njavascriptconst store = create(\n  persist(\n    ()=&gt;&#123;\n      ...\n    &#125;,\n    &#123;\n      name:&quot;xxx store&quot;, //必选\n      storage:createJSONStorage(()=&gt;sessionStorage) //用于选择存储方式\n    &#125;\n  )\n)还有一些细节配置如：选择（要&#x2F;不要）保存的值，保存成功后触发的回调，可以参考这篇文章\n第三方库zustand 的社区非常活跃有一些第三方的中间件可以实现更多功能，如计算属性等等，官方推荐的第三方库可以参考这篇文章\n异步获取数据zustand 原生支持异步获取数据，不用想 redux 那样使用 thunk 中间件加重开发者心智，直接用 async 和 await 修改数据即可\njavascriptconst useStore = create&lt;IAsync&gt;()((set) =&gt; &#123;\n  return &#123;\n    id: -1,\n    getId: async () =&gt; &#123;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const res:any = await fetch(&#39;/api/test/&#39;,);\n      const newId = await res.json();\n      set(&#123; id: newId.id &#125;);\n    &#125;,\n  &#125;;\n&#125;);你甚至可以结合 react query 等第三方库使用，eg：\njavascriptconst useFilterStore = create((set) =&gt; (&#123;\n  queryArr: [],\n  addFilter: (filter) =&gt;\n    set((state) =&gt; (&#123; applied: [...state.applied, filter] &#125;)),\n&#125;));\n\nexport const useAppliedFilters = () =&gt;\n  useFilterStore((state) =&gt; state.queryArray);\n\nexport const useFilteredTodos = () =&gt; &#123;\n  const filters = useAppliedFilters();\n  return useQuery(&#123;\n    queryKey: [&quot;todos&quot;, filters],\n    queryFn: () =&gt; getTodos(filters),\n  &#125;);\n&#125;;getState 和 setState你可以通过 getState 和 setState 这两个函数在 store 外面获取 store 的属性和修改 store 的属性。这样你可以在函数组件中定义修改 store 的函数，也可以在一个 store 中获取或修改另一个 store 的属性，还可以改变消费 store 的方式。\n跨 store 获取数据，eg：\njavascriptexport const useBStore =\n  create &lt;\n  IBStore &gt;\n  ((set, get) =&gt; (&#123;\n    B: 0,\n    addB: () =&gt; &#123;\n      set(&#123; B: ++get().B &#125;);\n    &#125;,\n    getSum: () =&gt; &#123;\n      return get().B + useAStore.getState().A;\n    &#125;,\n  &#125;));在store修改store属性的eg：\njavascriptexport const addA = () =&gt; &#123;\n  useAStore.setState((state) =&gt; (&#123; A: ++state.A &#125;));\n&#125;;通过这种方式定义函数的话，引入函数就是直接从ts文件中引入，而不是用hook的方式引入。\n","slug":"zustand","date":"2023-11-25T17:37:41.000Z","categories_index":"","tags_index":"","author_index":"CeazzZY"}]