[{"id":"95e1d6877ea327ec4515e34d7f460889","title":"zustand","content":"为什么要使用 zustand\n写法比较简便，你甚至不需要根组件外面包裹一层东西，足够轻量（核心代码只有 1kb）。\n写法大部分（小部分写法我感觉也很逆天）比较符合我的审美（仅仅是我的审美），不需要结合上下文，纯 hook 式调用。\n写法更接近于 redux，虽然我很讨厌 redux 繁琐的写饭，但不不得不承认，今后进入公司一些老项目大概率会是用的 redux，熟悉类似 redux 写法的话，有利于上手。\n在新兴的状态管理库中，热度基本排在数一数二的位置，github 上目前已有 37k 的 star，谈热度并不是让大家去盲目的跟风，庞大的社区可以给为使用者提供解决问题的成熟方案，和各种各样的中间件来扩展功能。\n\n初始化一个简单 storejavascriptimport &#123; create &#125; from &quot;zustand&quot;;\n\ninterface IStu &#123;\n  number: number;\n  add: () =&gt; void;\n  sub: () =&gt; void;\n  remove: ()=&gt;void\n&#125;\n\nconst store = create&lt;IStu&gt;()((set, get) =&gt; &#123;\n  return &#123;\n    number: 0,\n    add: () =&gt; &#123;\n      set((state) =&gt; &#123;\n        return &#123;\n          number: ++state.number,\n        &#125;;\n      &#125;);\n    &#125;,\n    sub: () =&gt; &#123;\n      set((state) =&gt; (&#123; number: --state.number &#125;));\n    &#125;,\n    remove: () =&gt; set(&#123; number: 0 &#125;),\n    otherAdd: () =&gt; &#123;\n      set(&#123; number: ++get().number &#125;);\n    &#125;,\n  &#125;;\n&#125;);\n\nexport default useStudentsStore;\n几个要注意的点：\n\n使用 ts 的话一定，要写类型声明不然会报错。\n范式声明后面要加括号，至于为什么我没太看懂（大概是跟柯里化相关），有兴趣可以看下这篇文章。\n看清楚 create 里的结构:\n\njavascriptcreate(()=&gt;&#123; //create中传入的是一个函数，函数接收一系列方法，之后会提到\n  return&#123;  //函数返回的是一个对象，对象中包含储存的值和修改值的方法。\n    ...\n  &#125;\n&#125;)消费 storejavascriptconst number = useStudentsStore((state) =&gt; state.number);\nconst add = useStudentsStore((state) =&gt; state.add); //最基本的使用方式\n\nconst &#123; number, add, sub, remove &#125; = useStudentsStore(); //仅使用于需要全部全部状态和方法，可能会引起不必要的渲染如果需要使用多个状态或值的话声明会很麻烦，所以作者写了一个 util，我们使用时只需要复制粘贴这段代码即可,愿文章\njavascriptimport &#123; StoreApi, UseBoundStore &#125; from &#39;zustand&#39;\n\ntype WithSelectors&lt;S&gt; = S extends &#123; getState: () =&gt; infer T &#125;\n  ? S &amp; &#123; use: &#123; [K in keyof T]: () =&gt; T[K] &#125; &#125;\n  : never\n\nexport const createSelectors = &lt;S extends UseBoundStore&lt;StoreApi&lt;object&gt;&gt;&gt;(\n  _store: S,\n) =&gt; &#123;\n  const store = _store as WithSelectors&lt;typeof _store&gt;\n  store.use = &#123;&#125;\n  for (const k of Object.keys(store.getState())) &#123;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (store.use as any)[k] = () =&gt; store((s) =&gt; s[k as keyof typeof s])\n  &#125;\n\n  return store\n&#125;javascript//store中用createSelectors包住store\nconst useStudentsStore = createSelectors(store);\n\n//在组件中用use的方式引入\nconst add = useStudentsStore.use.add();\nconst sub = useStudentsStore.use.sub();\nconst remove = useStudentsStore.use.remove();其实就算使用 selectors 的方式引入还是会有点麻烦.\nuseshallowuseShallow 是 zustand 中内置的一个 hook，使用 useShallow 为我们消费 store 提供了另一种方法。\njavascriptconst &#123; add1 &#125; = useShallowStore(\n  useShallow((state) =&gt; (&#123;\n    add1: state.add1,\n  &#125;))\n);这种写法可以避免组件的无意义刷新，简化了消费 store 的代码\n中间件devtools因为 zustand 是 redux 系的状态管理库，所以 zustand 可以直接使用 redux 的调试工具\njavascriptconst store = create(\n  devtools(\n    ()=&gt;&#123;\n      ...\n    &#125;\n  )\n)\nimmerzustand 中的 set 是一个纯函数，所以 state 是 immutable，当我们需要修改乔迁套很深的对象时需要大量使用对象解构，这样的写法非常麻烦。我们可以使用中间件 immer 来简化写法。首先 immer 并没有内置在 zustand 中，需要手动下载\ntxtpnpm i immer使用方式：\njavascriptconst store = create(\n  immer((set) =&gt; (&#123;\n    number: &#123;\n      mathTeacher: &#123;\n        man: 0,\n        woman: 0,\n      &#125;,\n      EnglishTeacher: 0,\n    &#125;,\n    addMathManTeacher: () =&gt; &#123;\n      set((state) =&gt; &#123;\n        state.number.mathTeacher.man += 1; //我们可以直接修改对象的属性\n      &#125;);\n    &#125;,\n  &#125;))\n);persist这个中间件用于持久化仓库里的值，即使页面刷新也不会丢失，\njavascriptconst store = create(\n  persist(\n    ()=&gt;&#123;\n      ...\n    &#125;,\n    &#123;\n      name:&quot;xxx store&quot;, //必选\n      storage:createJSONStorage(()=&gt;sessionStorage) //用于选择存储方式\n    &#125;\n  )\n)还有一些细节配置如：选择（要&#x2F;不要）保存的值，保存成功后触发的回调，可以参考这篇文章\n第三方库zustand 的社区非常活跃有一些第三方的中间件可以实现更多功能，如计算属性等等，官方推荐的第三方库可以参考这篇文章\n异步获取数据zustand 原生支持异步获取数据，不用想 redux 那样使用 thunk 中间件加重开发者心智，直接用 async 和 await 修改数据即可\njavascriptconst useStore = create&lt;IAsync&gt;()((set) =&gt; &#123;\n  return &#123;\n    id: -1,\n    getId: async () =&gt; &#123;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const res:any = await fetch(&#39;/api/test/&#39;,);\n      const newId = await res.json();\n      set(&#123; id: newId.id &#125;);\n    &#125;,\n  &#125;;\n&#125;);你甚至可以结合 react query 等第三方库使用，eg：\njavascriptconst useFilterStore = create((set) =&gt; (&#123;\n  queryArr: [],\n  addFilter: (filter) =&gt;\n    set((state) =&gt; (&#123; applied: [...state.applied, filter] &#125;)),\n&#125;));\n\nexport const useAppliedFilters = () =&gt;\n  useFilterStore((state) =&gt; state.queryArray);\n\nexport const useFilteredTodos = () =&gt; &#123;\n  const filters = useAppliedFilters();\n  return useQuery(&#123;\n    queryKey: [&quot;todos&quot;, filters],\n    queryFn: () =&gt; getTodos(filters),\n  &#125;);\n&#125;;getState 和 setState你可以通过 getState 和 setState 这两个函数在 store 外面获取 store 的属性和修改 store 的属性。这样你可以在函数组件中定义修改 store 的函数，也可以在一个 store 中获取或修改另一个 store 的属性，还可以改变消费 store 的方式。\n跨 store 获取数据，eg：\njavascriptexport const useBStore =\n  create &lt;\n  IBStore &gt;\n  ((set, get) =&gt; (&#123;\n    B: 0,\n    addB: () =&gt; &#123;\n      set(&#123; B: ++get().B &#125;);\n    &#125;,\n    getSum: () =&gt; &#123;\n      return get().B + useAStore.getState().A;\n    &#125;,\n  &#125;));在store修改store属性的eg：\njavascriptexport const addA = () =&gt; &#123;\n  useAStore.setState((state) =&gt; (&#123; A: ++state.A &#125;));\n&#125;;通过这种方式定义函数的话，引入函数就是直接从ts文件中引入，而不是用hook的方式引入。\n","slug":"zustand","date":"2023-11-25T17:37:41.000Z","categories_index":"","tags_index":"","author_index":"CeazzZY"}]