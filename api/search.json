[{"id":"91c3589b50232bba714925559327a526","title":"leetcode一百道纪念","content":"以 400 道为最终目标 继续努力","slug":"leetcode一百道纪念","date":"2024-04-09T16:27:03.000Z","categories_index":"","tags_index":"学习","author_index":"CeazzZY"},{"id":"00d35abee004b59e7ba4ba8f9e571046","title":"axios封装","content":"javascriptimport Axios from &#39;axios&#39;;\n\nimport &#123; BASE_URL &#125; from &#39;@/services&#39;;\nimport &#123; updateToken &#125; from &#39;@/services/login&#39;;\n\nimport &#123; antdUtils &#125; from &#39;./antd&#39;;\n\ninterface IRequestQueue &#123;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  resolve: any;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  config: any;\n  type: &#39;request&#39; | &#39;response&#39;;\n&#125;\n\nconst request = Axios.create(&#123;\n  baseURL: BASE_URL,\n  timeout: 5000,\n&#125;);\n\nconst refreshTokenUrl = &#39;&#39;;\nlet refreshTokenFlag = false;\nconst requestQueue: IRequestQueue[] = [];\nlet requestingCount = 0;\nconst limit = 3;\n\nrequest.interceptors.request.use((config) =&gt; &#123;\n  if ([refreshTokenUrl].includes(config.url || &#39;&#39;)) &#123;\n    return Promise.resolve(config);\n  &#125;\n\n  if (refreshTokenFlag || requestingCount &gt;= limit) &#123;\n    return new Promise((resolve) =&gt; &#123;\n      requestQueue.push(&#123;\n        resolve,\n        config: config,\n        type: &#39;request&#39;,\n      &#125;);\n    &#125;);\n  &#125;\n\n  requestingCount += 1;\n\n  const token = localStorage.getItem(&#39;token&#39;);\n  if (token) &#123;\n    config.headers.Authorization = `Bearer $&#123;token&#125;`;\n  &#125;\n  return config;\n&#125;);\n\nrequest.interceptors.response.use(\n  (response) =&gt; &#123;\n    if (response.config.url !== refreshTokenUrl) &#123;\n      requestingCount -= 1;\n      if (requestQueue.length) &#123;\n        requestByQueue();\n      &#125;\n    &#125;\n\n    const data = response.data;\n\n    if (response.status === 200) &#123;\n      if (data.status === 20003) &#123;\n        return new Promise((resolve) =&gt; &#123;\n          requestQueue.unshift(&#123;\n            resolve,\n            config: response.config,\n            type: &#39;response&#39;,\n          &#125;);\n          if (refreshTokenFlag) return;\n          refreshToken();\n        &#125;);\n      &#125; else &#123;\n        return data;\n      &#125;\n    &#125;\n    return Promise.reject(new Error(response.statusText || &#39;Error&#39;));\n  &#125;,\n  (error) =&gt; &#123;\n    requestingCount -= 1;\n\n    console.log(&#39;err:&#39;, error, error.response);\n    if (error.response &amp;&amp; error.response.status) &#123;\n      switch (error.response.status) &#123;\n        // 401: 未登录\n        // 未登录则跳转登录页面，并携带当前页面的路径\n        // 在登录成功后返回当前页面，这一步需要在登录页操作。\n        case 401:\n          window.location.hash = &#39;#/login&#39;;\n          break;\n        // 403 token过期\n        // 登录过期对用户进行提示\n        // 清除本地token和清空vuex中token对象\n        // 跳转登录页面\n        case 403:\n          window.location.hash = &#39;#/login&#39;;\n          break;\n        // 404请求不存在\n        case 404:\n          antdUtils.notification?.error(&#123;\n            message: `请求不存在`,\n            description: error.response.data?.info || &#39;Error&#39;,\n            duration: 1.5,\n          &#125;);\n          break;\n        case 400:\n          antdUtils.notification?.error(&#123;\n            message: `请求参数有误`,\n            description: error.response.data?.info || &#39;Error&#39;,\n            duration: 1.5,\n          &#125;);\n          break;\n        case 503:\n          antdUtils.notification?.error(&#123;\n            message: `服务器开小差了`,\n            description: error.response.data || &#39;Error&#39;,\n            duration: 1.5,\n          &#125;);\n          break;\n        case 409:\n          antdUtils.notification?.error(&#123;\n            message: `名称重复`,\n            description: &#39;请更换为可用名称&#39;,\n            duration: 1.5,\n          &#125;);\n          break;\n        default:\n          antdUtils.notification?.error(&#123;\n            message: `请求错误`,\n            description: error.response.data?.info || &#39;Error&#39;,\n            duration: 1.5,\n          &#125;);\n      &#125;\n    &#125;\n    return Promise.reject(error);\n  &#125;\n);\n\nfunction requestByQueue() &#123;\n  if (!requestQueue.length) return;\n\n  Array.from(&#123; length: limit - requestingCount &#125;).forEach(async () =&gt; &#123;\n    const record = requestQueue.shift();\n    if (!record) &#123;\n      return;\n    &#125;\n\n    const &#123; config, resolve, type &#125; = record;\n    if (type === &#39;response&#39;) &#123;\n      resolve(await request(config));\n    &#125; else if (type === &#39;request&#39;) &#123;\n      requestingCount += 1;\n      const token = localStorage.getItem(&#39;token&#39;);\n      config.headers.Authorization = `Bearer $&#123;token&#125;`;\n      resolve(config);\n    &#125;\n  &#125;);\n&#125;\n\nasync function refreshToken() &#123;\n  refreshTokenFlag = true;\n  const userStatus = localStorage.getItem(&#39;userStatus&#39;);\n  const refreshToken = localStorage.getItem(&#39;refreshToken&#39;);\n\n  if (!refreshToken || userStatus !== &#39;login&#39;) window.location.hash = &#39;#/login&#39;;\n\n  const res = await updateToken(refreshToken as string);\n\n  if (res.data.status === 20004) window.location.hash = &#39;#/login&#39;;\n\n  const &#123; token, refreshToken: newRefreshToken &#125; = res.data;\n  localStorage.setItem(&#39;refreshToken&#39;, newRefreshToken);\n  localStorage.setItem(&#39;token&#39;, token);\n\n  refreshTokenFlag = false;\n\n  requestByQueue();\n&#125;\n\nexport default request;\n\n","slug":"axios封装","date":"2024-04-09T16:26:19.000Z","categories_index":"","tags_index":"学习,前端","author_index":"CeazzZY"},{"id":"230b1e91322b312b83be58c66b0964f6","title":"react源码-jsx","content":"1\n","slug":"react源码-jsx","date":"2023-11-29T12:29:44.000Z","categories_index":"","tags_index":"学习,前端,react,源码","author_index":"CeazzZY"},{"id":"e922c45316b34ea7126c49048c6ca8da","title":"尝试rust-1","content":"rust 有强大的保管理工具 cargo，跟 npm 相似。对于 rust 的项目而言一般使用\nrustcargo new filename来初始化项目。\n通过 cargo 来下载相关的依赖包。\ntxtcargo add packagerustfn main()&#123;&#125;作为程序的入口。\n数据声明声明变量在 rust 中，使用 let 来声明变量，但仅用 let 声明的变量仍然是不可变的要通过 mut 关键字来让变量可变。eg：\nrustlet x = 1; //x是不可变的\nlet mut y = 2; //y是可变的\n\nx = 2; //会报错\ny = 1; //不会报错\n常量声明常量使用 const 来声明，在 rust 中常亮通常用全部大写表示，当有多个单词时用 _ 隔开。eg：\nrustconst MAX_POINT = 100;shadowing&#x2F;隐藏当我们使用相同的变量名定义新变量时，会 shadow 之前定义的变量。并且可以改变变量的类型。eg：\nrustlet x = 1;\nlet x = &quot;   &quot;；数据类型元祖与数组相比 tuple 中的类型可以不一样eg:\nrustlet tup:(i32,char,u8) = (23,&#39;w&#39;,1) //tuple的申明\n\nprintln!(&quot;&#123;&#125;&quot;,tup.1) //tuple的访问\n\nlet(a,b,c) = tup //tuple的解构数组rustlet [i32;5] = [1,2,3,4,5] //基本与其他语言类似 申明时第一个代表类型第二个代表个数语句与表达值在 rust 中可以把表达式赋值给变量，但不能把语句赋值给变量。eg：\nrust    let x = &#123;\n        let y = 1;\n        y+3  //默认将大括号内的最后一个表达式赋值给x，注意不能加 ； 因为加了分号就是一个语句不是表达式\n    &#125;;在函数中也同理eg：\nrustfn fun(x:i32) -&gt; i32 &#123;\n  x+5  //不加分号默认返回最后一个表达式，或用return返回\n&#125;","slug":"尝试rust-1","date":"2023-11-29T11:23:49.000Z","categories_index":"","tags_index":"学习,rust","author_index":"CeazzZY"},{"id":"82795e5babeacda4e2079c9fa98d4fbf","title":"next路由和路由跳转","content":"Routenext 的路由与 react 不同，不需要自己写路由表，在 next 中之需要你在 app&#x2F;pages（next14 中推荐 app）文件夹下写对应的文件夹或文件就能自动生成路由。不同名称的文件在路由中也有对应的功能。 components 之类的文件夹也能加到 app 文件夹中，但只要没有 page.tsx 就不会作为路由。\n页面pagepage 作为路由展示的主体内容，每一个作为路由的文件夹都必须有这个文件。\nlayoutlayout 作为不同子路由共用的布局，eg：\njavascriptexport default function DashboardLayout(&#123;\n  children,\n&#125;: &#123;\n  children: React.ReactNode,\n&#125;) &#123;\n  return (\n    &lt;section&gt;\n      &lt;div&gt;&lt;/div&gt; //共用UI\n      &#123;children&#125; //page展示的地方\n    &lt;/section&gt;\n  );\n&#125;放在 app 根 layout 需要包含 html 和 body 标签，因为 Next.js 不会自动创建它们。并且只有根 layout 能包含 html 和 body 标签。\ntemplatetemplate 的功能和 layout 十分相似，都是为子路由提供共用的 UI，但 template 在切换子路由后会重新渲染，layout 并不会，所以当共用 UI 中有依赖 useEffect 或根据逻辑展示不同内容的话 template 比 layout 更合适。\njavascriptexport default function Template(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;\n  return &lt;div&gt;&#123;children&#125;&lt;/div&gt;;\n&#125;loading用于处理加载中的 UI。并且可以使组件以一部分一部分的方式传输，提高性能。eg:\njavascriptexport default function Loading() &#123;\n  return &lt;div&gt;...&lt;/div&gt;;\n&#125;使用eg：\njavascript&lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;&lt;/Suspense&gt;跳转next 中切换路由的方式和 react 很相似，大体分为 link 跳转，和函数式跳转。\n&lt;link&gt;与 react-route 大体相似，包含 href，replace，scroll，prefetch 这几个属性，eg：\njavascript&lt;Link\n  className=&#123;`link $&#123;pathname === &quot;/&quot; ? &quot;active&quot; : &quot;&quot;&#125;`&#125; //是否处于活动状态\n  href=&#123;&#123;\n    pathname: \"/about\",\n    query: &#123; name: \"test\" &#125;,\n  &#125;&#125;\n  replace=&#123;false&#125; //决定跳转方式\n  prefetch=&#123;false&#125; //决定是否预渲染\n  scroll=&#123;false&#125; //决定是否默认到顶部\n&gt;\n  About\n&lt;/Link&gt;useRouter()与 react-route 中 navigate 大体相似，eg：\njavascriptconst router = useRouter();\nconst navigate = () =&gt; router.push(&quot;/home?id=1&quot;, &#123; scroll: false &#125;);\nrouter.replace();\nrouter.refresh();\nrouter.forward();\nrouter.back();Metadata为了更好的 SEO，可以通过 Metadata 来修改 title 内容，eg：\njavascript//在page中\nimport &#123; Metadata &#125; from &quot;next&quot;;\n\nexport const metadata: Metadata = &#123;\n  title: &quot;about&quot;,\n&#125;;路由组以(filename)创造的文件夹不会影响路由的 URL，但可以多个路由放到一个文件夹中，使路由结构更清晰。在路由组文件夹下还可以有 layout 文件来展示一个组中的共用 UI，如果是在 app 下的根 layout,可以删除 app 中的 layout，然后在每个路由组内添加一个 layout 文件，每个 layout 文件都有 html 和 body 标签。\n动态路由当你不确定 URL 时可以通过[filename]或[[filename]]的格式来创建文件夹。eg: blog&#x2F;[id] -&gt; blog&#x2F;1 -&gt; {id:1}[[filename]]可以匹配到 &#x2F;blog 但[filename]不行。在子组件中通过 props 的接收 params。eg:\njavascriptexport default function Page(&#123; params &#125;: &#123; params: &#123; slug: string &#125; &#125;) &#123;\n  return &lt;h1&gt;My Page&lt;/h1&gt;;\n&#125;[…folderName]可以接收后面的所有参数。eg：blog&#x2F;[…slug] -&gt; blog&#x2F;1&#x2F;a -&gt; {slug:[1,”a”]}\n","slug":"next路由和路由跳转","date":"2023-11-28T02:15:29.000Z","categories_index":"","tags_index":"学习,前端,react,nextjs","author_index":"CeazzZY"},{"id":"95e1d6877ea327ec4515e34d7f460889","title":"zustand","content":"为什么要使用 zustand\n\n\n写法比较简便，你甚至不需要根组件外面包裹一层东西，足够轻量（核心代码只有 1kb）。\n写法大部分（小部分写法我感觉也很逆天）比较符合我的审美（仅仅是我的审美），不需要结合上下文，纯 hook 式调用。\n写法更接近于 redux，虽然我很讨厌 redux 繁琐的写饭，但不不得不承认，今后进入公司一些老项目大概率会是用的 redux，熟悉类似 redux 写法的话，有利于上手。\n在新兴的状态管理库中，热度基本排在数一数二的位置，github 上目前已有 37k 的 star，谈热度并不是让大家去盲目的跟风，庞大的社区可以给为使用者提供解决问题的成熟方案，和各种各样的中间件来扩展功能。\n\n初始化一个简单 storejavascriptimport &#123; create &#125; from &quot;zustand&quot;;\n\ninterface IStu &#123;\n  number: number;\n  add: () =&gt; void;\n  sub: () =&gt; void;\n  remove: ()=&gt;void\n&#125;\n\nconst store = create&lt;IStu&gt;()((set, get) =&gt; &#123;\n  return &#123;\n    number: 0,\n    add: () =&gt; &#123;\n      set((state) =&gt; &#123;\n        return &#123;\n          number: ++state.number,\n        &#125;;\n      &#125;);\n    &#125;,\n    sub: () =&gt; &#123;\n      set((state) =&gt; (&#123; number: --state.number &#125;));\n    &#125;,\n    remove: () =&gt; set(&#123; number: 0 &#125;),\n    otherAdd: () =&gt; &#123;\n      set(&#123; number: ++get().number &#125;);\n    &#125;,\n  &#125;;\n&#125;);\n\nexport default useStudentsStore;\n几个要注意的点：\n\n使用 ts 的话一定，要写类型声明不然会报错。\n范式声明后面要加括号，至于为什么我没太看懂（大概是跟柯里化相关），有兴趣可以看下这篇文章。\n看清楚 create 里的结构:\n\njavascriptcreate(()=&gt;&#123; //create中传入的是一个函数，函数接收一系列方法，之后会提到\n  return&#123;  //函数返回的是一个对象，对象中包含储存的值和修改值的方法。\n    ...\n  &#125;\n&#125;)消费 storejavascriptconst number = useStudentsStore((state) =&gt; state.number);\nconst add = useStudentsStore((state) =&gt; state.add); //最基本的使用方式\n\nconst &#123; number, add, sub, remove &#125; = useStudentsStore(); //仅使用于需要全部全部状态和方法，可能会引起不必要的渲染如果需要使用多个状态或值的话声明会很麻烦，所以作者写了一个 util，我们使用时只需要复制粘贴这段代码即可,愿文章\njavascriptimport &#123; StoreApi, UseBoundStore &#125; from &#39;zustand&#39;\n\ntype WithSelectors&lt;S&gt; = S extends &#123; getState: () =&gt; infer T &#125;\n  ? S &amp; &#123; use: &#123; [K in keyof T]: () =&gt; T[K] &#125; &#125;\n  : never\n\nexport const createSelectors = &lt;S extends UseBoundStore&lt;StoreApi&lt;object&gt;&gt;&gt;(\n  _store: S,\n) =&gt; &#123;\n  const store = _store as WithSelectors&lt;typeof _store&gt;\n  store.use = &#123;&#125;\n  for (const k of Object.keys(store.getState())) &#123;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (store.use as any)[k] = () =&gt; store((s) =&gt; s[k as keyof typeof s])\n  &#125;\n\n  return store\n&#125;javascript//store中用createSelectors包住store\nconst useStudentsStore = createSelectors(store);\n\n//在组件中用use的方式引入\nconst add = useStudentsStore.use.add();\nconst sub = useStudentsStore.use.sub();\nconst remove = useStudentsStore.use.remove();其实就算使用 selectors 的方式引入还是会有点麻烦.\nuseshallowuseShallow 是 zustand 中内置的一个 hook，使用 useShallow 为我们消费 store 提供了另一种方法。\njavascriptconst &#123; add1 &#125; = useShallowStore(\n  useShallow((state) =&gt; (&#123;\n    add1: state.add1,\n  &#125;))\n);这种写法可以避免组件的无意义刷新，简化了消费 store 的代码\n中间件devtools因为 zustand 是 redux 系的状态管理库，所以 zustand 可以直接使用 redux 的调试工具\njavascriptconst store = create(\n  devtools(\n    ()=&gt;&#123;\n      ...\n    &#125;\n  )\n)\nimmerzustand 中的 set 是一个纯函数，所以 state 是 immutable，当我们需要修改乔迁套很深的对象时需要大量使用对象解构，这样的写法非常麻烦。我们可以使用中间件 immer 来简化写法。首先 immer 并没有内置在 zustand 中，需要手动下载\ntxtpnpm i immer使用方式：\njavascriptconst store = create(\n  immer((set) =&gt; (&#123;\n    number: &#123;\n      mathTeacher: &#123;\n        man: 0,\n        woman: 0,\n      &#125;,\n      EnglishTeacher: 0,\n    &#125;,\n    addMathManTeacher: () =&gt; &#123;\n      set((state) =&gt; &#123;\n        state.number.mathTeacher.man += 1; //我们可以直接修改对象的属性\n      &#125;);\n    &#125;,\n  &#125;))\n);persist这个中间件用于持久化仓库里的值，即使页面刷新也不会丢失，\njavascriptconst store = create(\n  persist(\n    ()=&gt;&#123;\n      ...\n    &#125;,\n    &#123;\n      name:&quot;xxx store&quot;, //必选\n      storage:createJSONStorage(()=&gt;sessionStorage) //用于选择存储方式\n    &#125;\n  )\n)还有一些细节配置如：选择（要&#x2F;不要）保存的值，保存成功后触发的回调，可以参考这篇文章\n第三方库zustand 的社区非常活跃有一些第三方的中间件可以实现更多功能，如计算属性等等，官方推荐的第三方库可以参考这篇文章\n异步获取数据zustand 原生支持异步获取数据，不用想 redux 那样使用 thunk 中间件加重开发者心智，直接用 async 和 await 修改数据即可\njavascriptconst useStore = create&lt;IAsync&gt;()((set) =&gt; &#123;\n  return &#123;\n    id: -1,\n    getId: async () =&gt; &#123;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const res:any = await fetch(&#39;/api/test/&#39;,);\n      const newId = await res.json();\n      set(&#123; id: newId.id &#125;);\n    &#125;,\n  &#125;;\n&#125;);你甚至可以结合 react query 等第三方库使用，eg：\njavascriptconst useFilterStore = create((set) =&gt; (&#123;\n  queryArr: [],\n  addFilter: (filter) =&gt;\n    set((state) =&gt; (&#123; applied: [...state.applied, filter] &#125;)),\n&#125;));\n\nexport const useAppliedFilters = () =&gt;\n  useFilterStore((state) =&gt; state.queryArray);\n\nexport const useFilteredTodos = () =&gt; &#123;\n  const filters = useAppliedFilters();\n  return useQuery(&#123;\n    queryKey: [&quot;todos&quot;, filters],\n    queryFn: () =&gt; getTodos(filters),\n  &#125;);\n&#125;;getState 和 setState你可以通过 getState 和 setState 这两个函数在 store 外面获取 store 的属性和修改 store 的属性。这样你可以在函数组件中定义修改 store 的函数，也可以在一个 store 中获取或修改另一个 store 的属性，还可以改变消费 store 的方式。\n跨 store 获取数据，eg：\njavascriptexport const useBStore =\n  create &lt;\n  IBStore &gt;\n  ((set, get) =&gt; (&#123;\n    B: 0,\n    addB: () =&gt; &#123;\n      set(&#123; B: ++get().B &#125;);\n    &#125;,\n    getSum: () =&gt; &#123;\n      return get().B + useAStore.getState().A;\n    &#125;,\n  &#125;));在store修改store属性的eg：\njavascriptexport const addA = () =&gt; &#123;\n  useAStore.setState((state) =&gt; (&#123; A: ++state.A &#125;));\n&#125;;通过这种方式定义函数的话，引入函数就是直接从ts文件中引入，而不是用hook的方式引入。\n","slug":"zustand","date":"2023-11-25T17:37:41.000Z","categories_index":"","tags_index":"学习,前端,react","author_index":"CeazzZY"}]